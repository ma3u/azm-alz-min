# Azure DevOps Pipeline for Azure Landing Zone
# Multi-stage deployment with Terraform 1.9, security scanning, and approval gates

trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
  paths:
    include:
      - infra/**
      - azure-pipelines.yml
      - scripts/**
      - .checkov.yaml

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - infra/**
      - azure-pipelines.yml
      - scripts/**

# Pipeline variables
variables:
  # Global settings
  - name: azureServiceConnection
    value: "azure-landingzone-service-connection"
  - name: terraformVersion
    value: "1.9.5"
  - name: azureRegion
    value: "westeurope"
  - name: vmImageName
    value: "ubuntu-latest"
  - name: pythonVersion
    value: "3.11"

  # Environment-specific variables
  - group: alz-sandbox-vars
  - group: alz-common-vars

# Define stages
stages:
  # =====================================================
  # STAGE 1: BUILD & VALIDATION
  # =====================================================

  - stage: BuildAndValidation
    displayName: "ğŸ” Build & Validation"
    jobs:
      - job: PreCommitValidation
        displayName: "ğŸ” Pre-commit Validation"
        pool:
          vmImage: $(vmImageName)

        steps:
          - checkout: self
            fetchDepth: 0
            displayName: "ğŸ›’ Checkout Repository"

          - task: UsePythonVersion@0
            inputs:
              versionSpec: $(pythonVersion)
              addToPath: true
            displayName: "ğŸ Setup Python"

          - script: |
              # Install pre-commit and validation tools
              pip install pre-commit==3.5.0
              pip install checkov==3.0.34
              pip install yamllint==1.33.0

              echo "âœ… Validation tools installed"
            displayName: "ğŸ“¦ Install Validation Tools"

          - script: |
              # Install and run pre-commit hooks
              pre-commit install

              # Run pre-commit on all files
              pre-commit run --all-files || {
                echo "âš ï¸ Pre-commit validation found issues"
                echo "##vso[task.logissue type=warning]Pre-commit hooks failed - see details above"
                # Don't fail build for warnings
                exit 0
              }

              echo "âœ… Pre-commit validation completed"
            displayName: "ğŸ” Run Pre-commit Hooks"
            continueOnError: true

      - job: SecurityScanning
        displayName: "ğŸ›¡ï¸ Security Scanning"
        dependsOn: PreCommitValidation
        pool:
          vmImage: $(vmImageName)

        steps:
          - checkout: self
            fetchDepth: 0
            displayName: "ğŸ›’ Checkout Repository"

          - task: UsePythonVersion@0
            inputs:
              versionSpec: $(pythonVersion)
              addToPath: true
            displayName: "ğŸ Setup Python"

          - script: |
              # Install Checkov
              pip install checkov==3.0.34

              echo "âœ… Security scanning tools installed"
            displayName: "ğŸ“¦ Install Security Tools"

          - script: |
              # Create reports directory
              mkdir -p $(Agent.TempDirectory)/reports

              # Run Checkov security scan
              checkov \
                --config-file .checkov.yaml \
                --directory infra/ \
                --output cli \
                --output sarif \
                --output-file-path $(Agent.TempDirectory)/reports/ \
                --quiet \
                --compact || {
                echo "âš ï¸ Security vulnerabilities detected"
                echo "##vso[task.logissue type=warning]Security scan found issues - review required"
                # Allow pipeline to continue for sandbox
                exit 0
              }

              echo "âœ… Security scanning completed"
            displayName: "ğŸ›¡ï¸ Run Checkov Security Scan"
            continueOnError: true

          - task: PublishTestResults@2
            condition: always()
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "$(Agent.TempDirectory)/reports/checkov.junit.xml"
              testRunTitle: "Checkov Security Scan"
            displayName: "ğŸ“Š Publish Security Scan Results"

      - job: TerraformValidation
        displayName: "ğŸ”§ Terraform Validation"
        dependsOn: SecurityScanning
        pool:
          vmImage: $(vmImageName)

        steps:
          - checkout: self
            displayName: "ğŸ›’ Checkout Repository"

          - script: |
              # Install Terraform 1.9
              wget -q https://releases.hashicorp.com/terraform/$(terraformVersion)/terraform_$(terraformVersion)_linux_amd64.zip
              unzip -q terraform_$(terraformVersion)_linux_amd64.zip
              sudo mv terraform /usr/local/bin/terraform
              sudo chmod +x /usr/local/bin/terraform

              # Create terraform1.9 symlink for consistency with documentation
              sudo ln -sf /usr/local/bin/terraform /usr/local/bin/terraform1.9

              # Verify installation
              terraform version
              terraform1.9 version

              echo "âœ… Terraform $(terraformVersion) installed"
            displayName: "ğŸ”§ Install Terraform 1.9"

          - script: |
              echo "ğŸ”§ Validating Terraform version requirements..."

              # Run version check script
              ./scripts/check-terraform-version.sh infra/terraform/simple-sandbox/main.tf || {
                echo "##vso[task.logissue type=warning]Terraform version validation issues found"
                exit 0  # Don't fail for warnings
              }

              echo "âœ… Terraform version validation completed"
            displayName: "ğŸ”§ Check Terraform Version Requirements"
            continueOnError: true

          - script: |
              cd infra/terraform/simple-sandbox

              echo "ğŸ” Initializing Terraform..."
              terraform init -backend=false

              echo "ğŸ” Validating Terraform configuration..."
              terraform validate

              echo "ğŸ” Checking Terraform formatting..."
              terraform fmt -check=true -diff=true

              echo "âœ… Terraform validation passed"
            displayName: "ğŸ” Validate Terraform Configuration"

  # =====================================================
  # STAGE 2: TERRAFORM PLAN (SANDBOX)
  # =====================================================

  - stage: TerraformPlanSandbox
    displayName: "ğŸ“‹ Terraform Plan (Sandbox)"
    dependsOn: BuildAndValidation
    condition: succeeded()
    jobs:
      - job: TerraformPlan
        displayName: "ğŸ“‹ Generate Terraform Plan"
        pool:
          vmImage: $(vmImageName)

        steps:
          - checkout: self
            displayName: "ğŸ›’ Checkout Repository"

          - script: |
              # Install Terraform 1.9
              wget -q https://releases.hashicorp.com/terraform/$(terraformVersion)/terraform_$(terraformVersion)_linux_amd64.zip
              unzip -q terraform_$(terraformVersion)_linux_amd64.zip
              sudo mv terraform /usr/local/bin/terraform
              sudo chmod +x /usr/local/bin/terraform
              sudo ln -sf /usr/local/bin/terraform /usr/local/bin/terraform1.9

              terraform version
            displayName: "ğŸ”§ Install Terraform 1.9"

          - task: AzureCLI@2
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              workingDirectory: "infra/terraform/simple-sandbox"
              inlineScript: |
                echo "ğŸ“‹ Initializing Terraform for planning..."

                # Initialize Terraform with Azure backend
                terraform init \
                  -backend-config="resource_group_name=$(TF_VAR_backend_resource_group)" \
                  -backend-config="storage_account_name=$(TF_VAR_backend_storage_account)" \
                  -backend-config="container_name=$(TF_VAR_backend_container)" \
                  -backend-config="key=alz-sandbox.tfstate"

                echo "ğŸ“‹ Generating Terraform plan..."

                # Create Terraform plan
                terraform plan \
                  -var-file="terraform.tfvars" \
                  -var="subscription_id=$(ARM_SUBSCRIPTION_ID)" \
                  -var="tenant_id=$(ARM_TENANT_ID)" \
                  -var="client_id=$(ARM_CLIENT_ID)" \
                  -var="client_secret=$(ARM_CLIENT_SECRET)" \
                  -out="tfplan" \
                  -detailed-exitcode \
                  -no-color | tee terraform-plan-output.txt

                # Capture plan exit code
                PLAN_EXIT_CODE=$?
                echo "Plan exit code: $PLAN_EXIT_CODE"

                if [[ $PLAN_EXIT_CODE -eq 1 ]]; then
                  echo "âŒ Terraform plan failed"
                  exit 1
                elif [[ $PLAN_EXIT_CODE -eq 2 ]]; then
                  echo "ğŸ“ Terraform plan detected changes"
                  echo "##vso[task.setvariable variable=planHasChanges;isOutput=true]true"
                else
                  echo "âœ… Terraform plan - no changes needed"
                  echo "##vso[task.setvariable variable=planHasChanges;isOutput=true]false"
                fi

                # Generate human-readable plan summary
                terraform show -no-color tfplan > terraform-plan-details.txt

                echo "âœ… Terraform plan generation completed"
            name: planStep
            displayName: "ğŸ“‹ Generate Terraform Plan"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "infra/terraform/simple-sandbox"
              artifactName: "terraform-plan-sandbox"
              publishLocation: "Container"
            displayName: "ğŸ“¦ Publish Terraform Plan Artifacts"

  # =====================================================
  # STAGE 3: DEPLOYMENT APPROVAL & SANDBOX APPLY
  # =====================================================

  - stage: DeploySandbox
    displayName: "ğŸš€ Deploy to Sandbox"
    dependsOn:
      - TerraformPlanSandbox
    condition: and(succeeded(), eq(dependencies.TerraformPlanSandbox.outputs['TerraformPlan.planStep.planHasChanges'], 'true'))
    jobs:
      - deployment: DeployToSandbox
        displayName: "ğŸš€ Deploy ALZ to Sandbox"
        pool:
          vmImage: $(vmImageName)
        environment: "alz-sandbox"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "ğŸ›’ Checkout Repository"

                - download: current
                  artifact: "terraform-plan-sandbox"
                  displayName: "ğŸ“¥ Download Terraform Plan"

                - task: AzureCLI@2
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      chmod +x ./scripts/deployment-coordinator.sh

                      echo "ğŸ¯ Attempting to acquire deployment lock..."
                      ./scripts/deployment-coordinator.sh acquire azdevops sandbox || {
                        echo "âŒ Failed to acquire deployment lock"
                        echo "Another deployment may be in progress (GitHub Actions or Azure DevOps)"

                        # Check lock status for details
                        ./scripts/deployment-coordinator.sh check sandbox || true

                        echo "ğŸ’¡ Options:"
                        echo "  1. Wait for the other deployment to complete"
                        echo "  2. Cancel this deployment"
                        echo "  3. Check the other pipeline's status"
                        echo "##vso[task.logissue type=error]Deployment lock acquisition failed - another deployment in progress"
                        exit 1
                      }

                      echo "âœ… Deployment lock acquired - proceeding with deployment"
                      echo "##vso[task.setvariable variable=deploymentLockAcquired]true"
                  displayName: "ğŸ¯ Acquire Deployment Lock"

                - script: |
                    # Install Terraform 1.9
                    wget -q https://releases.hashicorp.com/terraform/$(terraformVersion)/terraform_$(terraformVersion)_linux_amd64.zip
                    unzip -q terraform_$(terraformVersion)_linux_amd64.zip
                    sudo mv terraform /usr/local/bin/terraform
                    sudo chmod +x /usr/local/bin/terraform
                    sudo ln -sf /usr/local/bin/terraform /usr/local/bin/terraform1.9

                    terraform version
                  displayName: "ğŸ”§ Install Terraform 1.9"

                - task: AzureCLI@2
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    workingDirectory: "$(Pipeline.Workspace)/terraform-plan-sandbox"
                    inlineScript: |
                      echo "ğŸš€ Applying Terraform configuration to sandbox..."

                      # Initialize Terraform (backend already configured from plan stage)
                      terraform init \
                        -backend-config="resource_group_name=$(TF_VAR_backend_resource_group)" \
                        -backend-config="storage_account_name=$(TF_VAR_backend_storage_account)" \
                        -backend-config="container_name=$(TF_VAR_backend_container)" \
                        -backend-config="key=alz-sandbox.tfstate"

                      # Apply the pre-approved plan
                      terraform apply \
                        -auto-approve \
                        -no-color \
                        tfplan | tee terraform-apply-output.txt

                      # Extract outputs for testing
                      terraform output -json > terraform-outputs.json

                      echo "âœ… Terraform deployment completed successfully"
                  displayName: "ğŸš€ Apply Terraform Configuration"

                - script: |
                    echo "ğŸ§ª Running post-deployment validation tests..."

                    # Wait for resources to be fully provisioned
                    echo "â° Waiting 60 seconds for resources to stabilize..."
                    sleep 60

                    # Test resource groups
                    if az group show --name "rg-alz-hub-sandbox" --output none 2>/dev/null; then
                      echo "âœ… Hub resource group exists and is accessible"
                    else
                      echo "âŒ Hub resource group not found or not accessible"
                      exit 1
                    fi

                    if az group show --name "rg-alz-spoke-sandbox" --output none 2>/dev/null; then
                      echo "âœ… Spoke resource group exists and is accessible"
                    else
                      echo "âŒ Spoke resource group not found or not accessible"
                      exit 1
                    fi

                    # Test VNet connectivity
                    HUB_VNET_ID=$(az network vnet show --resource-group "rg-alz-hub-sandbox" --name "vnet-alz-hub-sandbox" --query id -o tsv 2>/dev/null || echo "")
                    SPOKE_VNET_ID=$(az network vnet show --resource-group "rg-alz-spoke-sandbox" --name "vnet-alz-spoke-sandbox" --query id -o tsv 2>/dev/null || echo "")

                    if [[ -n "$HUB_VNET_ID" && -n "$SPOKE_VNET_ID" ]]; then
                      echo "âœ… Hub and Spoke VNets exist"

                      # Check peering status
                      PEERING_STATUS=$(az network vnet peering list --resource-group "rg-alz-hub-sandbox" --vnet-name "vnet-alz-hub-sandbox" --query "[0].peeringState" -o tsv 2>/dev/null || echo "NotFound")

                      if [[ "$PEERING_STATUS" == "Connected" ]]; then
                        echo "âœ… VNet peering is connected and operational"
                      else
                        echo "âš ï¸ VNet peering status: $PEERING_STATUS"
                      fi
                    else
                      echo "âš ï¸ VNets not found - may not be part of this deployment"
                    fi

                    # Test web app (if exists)
                    WEB_APP_NAME=$(az webapp list --resource-group "rg-alz-spoke-sandbox" --query "[0].name" -o tsv 2>/dev/null || echo "")
                    if [[ -n "$WEB_APP_NAME" ]]; then
                      WEB_APP_URL=$(az webapp show --resource-group "rg-alz-spoke-sandbox" --name "$WEB_APP_NAME" --query "defaultHostName" -o tsv)
                      echo "ğŸŒ Testing web application: https://$WEB_APP_URL"

                      if curl -sSf "https://$WEB_APP_URL" > /dev/null 2>&1; then
                        echo "âœ… Web application is accessible and responding"
                      else
                        echo "âš ï¸ Web application not responding (may still be starting)"
                      fi
                    fi

                    echo "âœ… Post-deployment validation completed"
                  displayName: "ğŸ§ª Post-Deployment Validation"

                - script: |
                    echo "ğŸ’° Analyzing deployment costs..."

                    # Get cost data for the last 7 days
                    COST_START_DATE=$(date -d '7 days ago' +%Y-%m-%d)
                    COST_END_DATE=$(date +%Y-%m-%d)

                    echo "ğŸ“Š Fetching cost data from $COST_START_DATE to $COST_END_DATE"

                    COST_DATA=$(az consumption usage list \
                      --start-date "$COST_START_DATE" \
                      --end-date "$COST_END_DATE" \
                      --query '[].{Resource: instanceName, Cost: pretaxCost, Currency: currency}' \
                      --output json 2>/dev/null || echo '[]')

                    echo "Cost breakdown:"
                    echo "$COST_DATA" | jq -r '.[] | "\(.Resource): \(.Cost) \(.Currency)"' 2>/dev/null || echo "Cost data not available"

                    # Calculate total cost
                    TOTAL_COST=$(echo "$COST_DATA" | jq '[.[].Cost | tonumber] | add // 0' 2>/dev/null || echo "0")
                    echo "ğŸ’° Total estimated cost: $TOTAL_COST USD"

                    # Cost alerting
                    if (( $(echo "$TOTAL_COST > 50" | bc -l 2>/dev/null || echo 0) )); then
                      echo "##vso[task.logissue type=warning]âš ï¸ Cost Alert: Infrastructure costs exceed $50 USD"
                    elif (( $(echo "$TOTAL_COST > 25" | bc -l 2>/dev/null || echo 0) )); then
                      echo "##vso[task.logissue type=warning]ğŸ’¡ Cost Notice: Infrastructure costs approaching $25 USD threshold"
                    fi

                    echo "âœ… Cost analysis completed"
                  displayName: "ğŸ’° Cost Analysis"
                  continueOnError: true

                - task: AzureCLI@2
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      chmod +x ./scripts/deployment-coordinator.sh

                      echo "ğŸ”“ Releasing deployment lock after successful deployment..."
                      ./scripts/deployment-coordinator.sh release azdevops sandbox || {
                        echo "âš ï¸ Warning: Failed to release deployment lock"
                        echo "##vso[task.logissue type=warning]Could not release deployment lock - may already be released"
                        # Don't fail the deployment for this
                        true
                      }

                      echo "âœ… Deployment lock released - other pipelines can now deploy"
                  displayName: "ğŸ”“ Release Deployment Lock (Post-Deploy)"
                  condition: succeeded()

                - task: PublishBuildArtifacts@1
                  inputs:
                    pathToPublish: "$(Pipeline.Workspace)/terraform-plan-sandbox"
                    artifactName: "terraform-deployment-sandbox"
                    publishLocation: "Container"
                  displayName: "ğŸ“¦ Publish Deployment Artifacts"

  # =====================================================
  # STAGE 4: TESTING & MONITORING SETUP
  # =====================================================

  - stage: TestingAndMonitoring
    displayName: "ğŸ§ª Testing & Monitoring"
    dependsOn: DeploySandbox
    condition: succeeded()
    jobs:
      - job: IntegrationTesting
        displayName: "ğŸ§ª Integration Testing"
        pool:
          vmImage: $(vmImageName)

        steps:
          - checkout: self
            displayName: "ğŸ›’ Checkout Repository"

          - task: AzureCLI@2
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "ğŸ§ª Running comprehensive integration tests..."

                # Test 1: Resource Group Accessibility
                echo "ğŸ” Testing resource group accessibility..."
                for rg in "rg-alz-hub-sandbox" "rg-alz-spoke-sandbox"; do
                  if az group show --name "$rg" --output none 2>/dev/null; then
                    echo "âœ… Resource group $rg is accessible"
                  else
                    echo "âŒ Resource group $rg is not accessible"
                    exit 1
                  fi
                done

                # Test 2: Network Connectivity
                echo "ğŸŒ Testing network connectivity..."

                # Check VNet peering
                PEERING_COUNT=$(az network vnet peering list --resource-group "rg-alz-hub-sandbox" --vnet-name "vnet-alz-hub-sandbox" --query "length(@)" -o tsv 2>/dev/null || echo "0")

                if [[ "$PEERING_COUNT" -gt 0 ]]; then
                  echo "âœ… VNet peering configuration found ($PEERING_COUNT peering(s))"

                  # Check peering state
                  PEERING_STATE=$(az network vnet peering list --resource-group "rg-alz-hub-sandbox" --vnet-name "vnet-alz-hub-sandbox" --query "[0].peeringState" -o tsv 2>/dev/null || echo "Unknown")
                  echo "ğŸ”— Peering state: $PEERING_STATE"
                else
                  echo "âš ï¸ No VNet peering found - may not be configured in this deployment"
                fi

                # Test 3: Application Availability
                echo "ğŸš€ Testing application availability..."

                APP_COUNT=$(az webapp list --resource-group "rg-alz-spoke-sandbox" --query "length(@)" -o tsv 2>/dev/null || echo "0")

                if [[ "$APP_COUNT" -gt 0 ]]; then
                  WEB_APP_URL=$(az webapp list --resource-group "rg-alz-spoke-sandbox" --query "[0].defaultHostName" -o tsv)
                  echo "ğŸŒ Found web application: $WEB_APP_URL"

                  # Test HTTP response
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$WEB_APP_URL" || echo "000")
                  echo "ğŸ“¡ HTTP Status: $HTTP_STATUS"

                  if [[ "$HTTP_STATUS" -eq 200 ]]; then
                    echo "âœ… Web application is responding correctly"
                  elif [[ "$HTTP_STATUS" -eq 403 ]]; then
                    echo "âš ï¸ Web application is running but access may be restricted"
                  else
                    echo "âš ï¸ Web application status: $HTTP_STATUS (may be starting up)"
                  fi
                else
                  echo "â„¹ï¸ No web applications found in this deployment"
                fi

                # Test 4: Storage Account Access
                echo "ğŸ’¾ Testing storage account access..."

                STORAGE_COUNT=$(az storage account list --resource-group "rg-alz-spoke-sandbox" --query "length(@)" -o tsv 2>/dev/null || echo "0")

                if [[ "$STORAGE_COUNT" -gt 0 ]]; then
                  STORAGE_NAME=$(az storage account list --resource-group "rg-alz-spoke-sandbox" --query "[0].name" -o tsv)
                  echo "ğŸ’¾ Found storage account: $STORAGE_NAME"

                  # Check storage account accessibility
                  if az storage account show --name "$STORAGE_NAME" --resource-group "rg-alz-spoke-sandbox" --output none 2>/dev/null; then
                    echo "âœ… Storage account is accessible"
                  else
                    echo "âŒ Storage account is not accessible"
                  fi
                else
                  echo "â„¹ï¸ No storage accounts found in this deployment"
                fi

                echo "âœ… Integration testing completed successfully"
            displayName: "ğŸ§ª Run Integration Tests"

      - job: SetupMonitoring
        displayName: "ğŸ“Š Setup Monitoring"
        dependsOn: IntegrationTesting
        pool:
          vmImage: $(vmImageName)

        steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "ğŸ“Š Setting up monitoring and alerting..."

                # Check for Log Analytics workspace
                LOG_WORKSPACE=$(az monitor log-analytics workspace list --resource-group "rg-alz-hub-sandbox" --query "[0].name" -o tsv 2>/dev/null || echo "")

                if [[ -n "$LOG_WORKSPACE" ]]; then
                  echo "âœ… Log Analytics workspace found: $LOG_WORKSPACE"

                  # Get workspace ID for reference
                  WORKSPACE_ID=$(az monitor log-analytics workspace show --resource-group "rg-alz-hub-sandbox" --workspace-name "$LOG_WORKSPACE" --query "customerId" -o tsv)
                  echo "ğŸ“Š Workspace ID: $WORKSPACE_ID"
                else
                  echo "â„¹ï¸ No Log Analytics workspace found in this deployment"
                fi

                # Create basic cost alert
                echo "ğŸ’° Setting up cost monitoring alert..."

                SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                # Check if cost alert already exists
                EXISTING_ALERT=$(az monitor metrics alert list --query "[?contains(name,'alz-sandbox-cost-alert')].name" -o tsv 2>/dev/null || echo "")

                if [[ -z "$EXISTING_ALERT" ]]; then
                  echo "ğŸ’¡ Cost alert will be configured manually in Azure portal"
                  echo "   Navigate to Cost Management + Billing > Budgets"
                  echo "   Create budget alert for subscription: $SUBSCRIPTION_ID"
                else
                  echo "âœ… Cost alert already configured: $EXISTING_ALERT"
                fi

                echo "âœ… Monitoring setup completed"
            displayName: "ğŸ“Š Configure Monitoring"
            continueOnError: true

  # =====================================================
  # STAGE 5: CLEANUP (Feature Branches Only)
  # =====================================================

  - stage: Cleanup
    displayName: "ğŸ§¹ Cleanup (Feature Branches)"
    dependsOn: TestingAndMonitoring
    condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'))
    jobs:
      - job: ManualApprovalForCleanup
        displayName: "â¸ï¸ Approval Required"
        pool: server
        timeoutInMinutes: 4320 # 3 days
        steps:
          - task: ManualValidation@0
            timeoutInMinutes: 4320
            inputs:
              notifyUsers: |
                $(Build.RequestedForEmail)
              instructions: |
                ğŸ§¹ **Feature Branch Cleanup Approval**

                This is a feature branch deployment that will be automatically cleaned up.

                **Branch:** $(Build.SourceBranch)
                **Resources to clean up:**
                - rg-alz-hub-sandbox
                - rg-alz-spoke-sandbox

                **Options:**
                âœ… **Approve** - Proceed with cleanup (recommended for feature branches)
                âŒ **Reject** - Keep resources for extended testing (will incur costs)

                ğŸ’¡ You have 3 days to make this decision, after which the pipeline will timeout.

      - deployment: CleanupFeatureBranch
        displayName: "ğŸ§¹ Cleanup Feature Branch Resources"
        dependsOn: ManualApprovalForCleanup
        pool:
          vmImage: $(vmImageName)
        environment: "alz-sandbox-cleanup"
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      chmod +x ./scripts/deployment-coordinator.sh

                      echo "ğŸ”“ Releasing deployment lock..."
                      ./scripts/deployment-coordinator.sh release azdevops sandbox || {
                        echo "âš ï¸ Warning: Failed to release deployment lock"
                        echo "##vso[task.logissue type=warning]Could not release deployment lock"
                        # Don't fail cleanup for this
                        true
                      }

                      echo "âœ… Deployment lock released"
                  displayName: "ğŸ”“ Release Deployment Lock"
                  condition: always()

                - task: AzureCLI@2
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "ğŸ§¹ Starting cleanup of feature branch resources..."
                      echo "Branch: $(Build.SourceBranch)"

                      # List resources before cleanup
                      echo "ğŸ“‹ Resources to be cleaned up:"
                      az group list --query "[?contains(name,'sandbox')].{Name:name, Location:location}" -o table 2>/dev/null || echo "No resource groups found"

                      # Clean up resource groups
                      for rg in "rg-alz-hub-sandbox" "rg-alz-spoke-sandbox"; do
                        if az group show --name "$rg" --output none 2>/dev/null; then
                          echo "ğŸ—‘ï¸ Deleting resource group: $rg"
                          az group delete --name "$rg" --yes --no-wait
                        else
                          echo "â„¹ï¸ Resource group $rg does not exist or already deleted"
                        fi
                      done

                      echo "âœ… Cleanup initiated - resources will be deleted asynchronously"
                      echo "ğŸ’¡ Monitor cleanup progress in Azure Portal"
                  displayName: "ğŸ§¹ Delete Feature Branch Resources"
